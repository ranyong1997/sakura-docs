---
date: "2021/12/02"
categories: [面经]
stick: true
tag: [面试经历]
---

# 面经

## 深浅拷贝

浅拷贝:构造一个新的集合对象，用原始对象中找到的子对象的引用来填充它，复制过程不会递归，不会创建子对象的副本。

深拷贝：构造一个集合对象，递归的用在原始对象中找到的子对象的副本来填充它，创建原始对象及其所有子对象完全独立的克隆。

## is和==的区别

`is`判断两个对象的内存地址是否相同 而`==`判断两个对象的值是否相同

`==`本质是（`equal()`）

## 装饰器

本质上是一个嵌套函数，接收被装饰的函数(`func`)作为参数，并返回一个包装过的函数，以实现不影响函数的情况下添加新的功能。

## 闭包

如果一个外函数中定义一个内函数，且内函数内引用到了外函数的变量，这时外函数通过`return`返回内函数的引用时，会把定义时设计到的外部引用变量与内函数打包成一个整体，即闭包。

## python的内存管理机制

Python中的垃圾回收主要以`引入计数`为主，再引入`标记`、`清楚`、`分代为辅`来解决循环引入的问题。

一个对象被引入时，引用计数加1，当对象被del时，引入计数减1，为0时，对象就被清除。

## Linux常用命令

- ls 列出当前文件夹下的内容

- pwd 查看当前所在目录

- cd 切换目录，cd.. 返回上一层

- touch 创建文件

- mkdir 新建目录

- rm 删除文件 rm -r 目录名 删除目录 rm -f 强制删除

- cp 复制文件

- mv 移动文件

- grep 搜索文本、文件名

- cat 显示文件完整内容 more 分屏显示文件内容 less 分屏显示文件内容

  head -n 打印前几行 tail -n 打印末尾几行

- top 动态实时显示cpu、内存、进程使用情况

- ps 列出进程 ps -ef ｜ grep xxx 查看xx进程

​		ps -a 列出所有进程

- kill 杀死进程 kill -9 pid 强制杀死某进程
- free 显示当前内存使用情况
- su 切换用户 sudo 管理员
- chmod 修改权限
- linux 三剑客 【grep、sed、awk】

## OSI 七层

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

顺口溜：（`物数网传会表应`）

## TCP链接需要三次握手

两次握手只能保证单向连接时畅通的。

只有三次握手才能确保双向都可以接受到对方的发送的数据

## TCP如何处理拥塞

- 慢启动
- 拥塞避免
- 快重传
- 快恢复

## HTTP

HTTP1.1

- 持久连接
- 请求管道化
- 增加缓存处理
- 增加Host字段、支持断点传输

HTTP2.0

- 二进制分帧
- 多路复用
- 头部压缩
- 服务器推送

## HTTP和HTTPS的区别

- HTTPS协议需要到CA申请证书，一般免费证书较少，需要一定的费用

- HTTP时超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP 是80 HTTPS是443
- HTTP的连接简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输比HTTP协议安全

## 对称加密和非对称加密的区别和原理

对称密钥加密是指加密和解密使用同一个密钥的方式；非对称加密是指使用一对非堆成密钥，即公钥和私钥，公钥可以随意发布，但私钥只能自己知道。

## 常见的状态码

1xx：请求处理中，请求已被接受，正在处理

2xx：请求成功，请求被成功处理 200 ok

3xx：重定向，301:永久性转移；302:暂时性转移；304:已缓存

4xx：客户端错误，400:Bad Request,请求有语法问题；403:拒绝请求；404:客户端 所访问的页面不存在

5xx：服务端错误，500:服务器内部错误；503:服务不可用

## Get与POST的区别

- Get一般用来从服务器上获取资源；POST一般用来创建资源；
- GET是幂等的，即读取同一个资源，总是得到相同的数据；POST不是幂等的；GET不会改变服务器上的资源，而POST会对服务器资源进行改变
- Get请求的数据会附在URL之后；Post请求会把提交的数据则放置在HTTP请求报文的请求体中
- POST的安全性比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而POST请求参数则被包装到请求体中，相对安全。
- GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

## Session、Cookie、token的区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上。而token时接口测试时的鉴权码，一般情况下登陆后才可以获取token，然后在每次请求接口时需要带上token参数。
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session，session回在一定时间内保存在服务器上。当访问增多，会比较占用服务器性能，考虑到减轻服务器性能方面应当使用cookie
- 可以将登陆信息等重要信息存放在session；其他信息需要保存，例如头像，可以存放cookie

## 常用的测试方法

- 黑盒测试

不考虑内部结构，即具体代码的实现，检测软件的各个功能是否得以实现，确认软件功能的正确性，关注具体的客户端需求及软件功能

- 白盒测试

关注程序代码的具体细节，根据软件内部代码的逻辑结构来分析进行测试，关注代码的实现细节

- 灰盒测试

静态测试：在不运行程序的情况下寻找代码中可能存在的错误，或者评估程序代码

动态测试：实际运行被测程序，输入相应的测试用例，检查运行结果于预期结果的差异

阿尔法测试：一个用户在开发环境下的受控测试，模拟实际操作环境如：内测

贝塔测试：多个用户在实际使用环境下进行的测试，如公测

回归测试：我们测出bug后，然后返还给程序员修改，程序员修改后，进行同样操作看能不能复现

## 测试用例设计方法

- 等价类划分：将全部输入数据合理划分成若干个等价类，在每一个等价类中取一个数据作为输入条件，分为有效等价类和无效等价类
- 边界值分析法：大量错误是发生在输入输出范围的边界上，选定测试用例时应该选取正好等于、刚刚大于、刚刚小于边界值作为测试数据
- 错误猜测法：基于经验和直接推测列举出程序中所有可能的错误和容易发生错误的特殊情况
- 因果图法：考虑输入条件之间相互组合，也考虑输出结果对输入条件的依赖关系。
- 场景分析法：根据用户场景来模拟用户的操作步骤

## 软件测试阶段分类

- 单元测试

针对软件设计最小单位程序模块进行正确性检测

- 集成测试

在单元测试的基础上，将所有程序小模块组起来，进行有序的测试

- 系统测试

在系统的真实运行环境下，检查完整的程序系统是否可以和硬件、外设、网络和系统软件、支持平台等正确配置、连接。

- 验收测试

一般由供求双方共同达成，模拟用户实际运行的环境，对功能模块全面测试。

## 缺陷等级划分

- P0：致命【crash，死机，白屏】- 需要立即修复
- P1：严重【局限在一个模块，导致功能失常或异常退出】- 需要优先考虑
- P2：一般【模块功能全部失效】- 排队等待修复
- P3：建议【对该模块提出建议比如错别字等】- 有时间的时候修复

## 测试流程

需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试

## 缺陷的生命周期

新建bug--打开bug--修复bug--回归bug--关闭bug

## 软件测试的核心竞争力是什么

测试人员的核心竞争力在于提早发现问题，并能够发现别人无法发现的问题

- 早发现问题：问题发现越早，解决的成本越低。

## 测试项目具体工作

- 搭建测试环境
- 撰写测试用例
- 执行测试用例
- 写测试计划，测试报告
- 跟踪bug修改情况
- 执行自动化测试，编写脚本，执行，分析，报告
- 进行性能测试，压力测试，执行，分析，调优，报告

## Python的映射类型

字典

## 元祖列表字典区别

元祖：封闭的列表，一旦定义，就不可改变（添加、删除、修改）

列表：可以随意增加和删除任何东西 append() 添加 del()删除

```python
#!/usr/bin/python
# 访问列表
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5, 6, 7 ]
 
print "list1[0]: ", list1[0]
# list1[0]:  physics
print "list2[1:5]: ", list2[1:5]
# list2[1:5]:  [2, 3, 4, 5]

# 更新列表
list = []          ## 空列表
list.append('Google')   ## 使用 append() 添加元素
list.append('Runoob')
print (list)
# ['Google', 'Runoob']

# 删除列表
list1 = ['physics', 'chemistry', 1997, 2000]
 
print list1
del list1[2]
print ("After deleting value at index 2 : ")
print (list1)
# ['physics', 'chemistry', 2000]
```



字典：key-value键值对的形式，键唯一，且不可变 del 删除字典 

```python
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
 
dict['Age'] = 8 # 更新
dict['School'] = "RUNOOB" # 添加
 
print "dict['Age']: ", dict['Age']
# dict['Age']:  8
print "dict['School']: ", dict['School']
# dict['School']:  RUNOOB

del dict['Name']  # 删除键是'Name'的条目
dict.clear()      # 清空字典所有条目
del dict          # 删除字典
```

## 进程 线程 协程

### 进程

- 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立。
- 稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制。

### 线程

- CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享进程的所有资源。
- 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃。

### 协程

- 子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

## GIL

GIL是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程再运行python程序的时候会霸占python解释器(加了一把锁即GIL)，使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。

## 常见的web自动化元素定位方式

- id：根据id来获取元素，返回单个元素，id值一般是唯一的。
- name：根据元素的name属性定位
- tagName：根据元素的标签名定位
- className：根据元素的样式class值定位
- linkText：根据超链接的部分
- partialLinkText：css选择器定位
- xpath

## Fiddler抓包

### 断点方式有哪些

- Before Requests：在请求时，没有达到服务器之前设置断点。
- After responses：服务器响应之后，在fiddler将响应传回给客户端之前。
- Disabled 取消断点

### 为什么要设置断点

> 进行接口测试时，拦截和修改数据，测后端功能。比如：某图书网小说售价100元，进行网页前端的功能测试时，只能输入100元进行购买！但是通过fiddler抓包工具可以拦截，修改数据。防止跳过前端输入框验证，然后修改数据，输入-100元进行购买，这样的话，不仅买了小说，账户余额还增加100元。这样说明后端接口不对

### 怎么设置断点

- Rules>>Automatic Breakpoints>>Before Requests(After Response) -- 全局断点

- 在命令行输入:（单个断点）

  1.bpu 接口链接 然后回车 --before request

  2.bafter 接口链接 然后回车 -- after response

### 拦截来自某个网址所有请求

在命令行输入：bpu 网址

## Web性能测试工具

### Jmeter测试元件的执行顺序

配置元件->前置处理器->计时器->取样器->后置处理器->断言->监听器

### 什么是JMeter断言？断言的类型有哪些？

断言有助于验证被测服务器是否返回了预期结果。

JMeter中常见断言：

- 响应断言
- 持续时间断言
- 大小断言
- XML断言
- HTML断言

### 列出几个JMeter监听器？

- 集合报告
- 汇总报告
- 查看结果数
- 用表格查看结果
- 图形结果
- BeanShell Listener
- 摘要报告等

### 解释计时器(Timer)在JMeter中的作用是什么？

在计时器的帮助下，JMeter可以延迟线程发出的每个请求之间的时间。可以解决服务器的过载问题。

### 整体流程

JMeter的操作的整体流程，首先创建一个线程组，指定并发的线程数量，然后指定的要测试的接口，创建相应的监听器，比如表格结果，结果数和聚合报告信息，通过监听器来监听测试是否通过接口是否存在什么问题

其中结果树中可以检测到整体的请求信息，就拿Http请求这种来讲，其实就是整个http协议的所有信息，包括请求头，请求参数，请求路径，还有响应头，响应结果等信息，对于表格查看结果，可以看到每个请求的简单信息，本次请求的时间，以及平均时间。

在聚合报告中，我们就可以看到整体的信息了。比如可以看到平均响应时间，90%Line也就是90%的用户请求低于的时间。还有吞吐量TPS，还有错误率，还有流量来计算吞吐量。

吞吐量=（请求数）/（总时间）

### JMeter参数化

做压力测试时。我们经常需要替换参数，在JMeter中，可以在测试计划中设置全局参数，可以设置用户参数，还可以在前置处理器中设置用户参数。在进行多线程并发的时候，如果需要多个参数，可以使用csv配置元件。

### JMeter脚本录制

badboy录制

#### 
