---
date: "2021/11/02"
categories: [面经]
stick: false
tag: [面试经历]
---

# 面经

## 自我介绍

面试官您好，我叫xx，来自于xxx。做软件测试工作已经有x年了。在期间做了不少的项目，也积累了不少的测试经验，能够独立完成软件测试的测试工作，主要做过功能测试、app专项测试和接口测试方面的工作。对于linux、fiddler、jmeter熟悉。也用过jmeter做过一些性能测试。平常喜欢健身和摄影，这就是我一个简单的自我介绍，您看，我这边还需要什么补充吗？

## 在音视频项目中，需要测什么东西？

首先在音视频这个项目中，我们需要检测音视频是否正常通话，保障最基本的功能能正常使用。其次是在一些功能方面的测试，对每个模块进行单元测试，系统测试，集成测试。在是性能测试，我们需要对音视频这个SDK进行做性能测试，测它的流量、CPU、内存、流畅度等等。在就是进行自动化测试，又分接口自动化测试和ui自动化测试，最后进行回归测试。

## 深浅拷贝

浅拷贝：构造一个新的集合对象，用原始对象中找到的子对象的引用来填充它，复制过程不会递归，不会创建子对象的副本。【拷贝了引用，并没有拷贝内容】

深拷贝：构造一个集合对象，递归的用在原始对象中找到的子对象的副本来填充它，创建原始对象及其所有子对象完全独立的克隆。【进行所有的拷贝】

## is和==的区别

`is`判断两个对象的内存地址是否相同 而`==`判断两个对象的值是否相同`==`本质是（`equal()`）

## 装饰器

本质上是一个嵌套函数，接收被装饰的函数(`func`)作为参数，并返回一个包装过的函数，以实现不影响函数的情况下添加新的功能。

## 闭包

如果一个外函数中定义一个内函数，且内函数内引用到了外函数的变量，这时外函数通过`return`返回内函数的引用时，会把定义时设计到的外部引用变量与内函数打包成一个整体，即闭包。

## python的内存管理机制

Python中的垃圾回收主要以`引入计数`为主，再引入`标记`、`清除`、`分代为辅`来解决循环引入的问题。

一个对象被引入时，引用计数加1，当对象被del时，引入计数减1，为0时，对象就被清除。

## __new__和init的区别

- 首先用法不同，`__new__()`用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；
  - `__init__()`用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。
  - `__new__()`在`__init__()`之前被调用。如果`__new__()`创建的是当前类的实例，会自动调用`__init__()`函数，通过return调用`__new__()`的参数cls来保证当前类实例
- 其次是返回值不同，`__new__()`必须有返回值，返回实例对象；
  - `__init__()`不需要返回值。

## python如何字符串切割

采用`split("_")`这样就以"_"进行分割

## python怎么声明私有变量

在python类中定义私有变量只要在前面加上`__`,那么该类的实例就不能引用了

## python怎么获取一个对象的所有属性？

`dir()`

## python有那些常用的数据结构(类型)

- 数字
- 字符串
- 列表
- 元组
- 字典
- 集合

## python写一个阶乘函数

```python
def num(n):
    if n == 1:
        return n
    return n * num(n - 1)

print(num(10))
# 输出
3628800
```

## python格式化输出

- 用%占位符进行格式化输出
  - %d - 代表输出的内容是整数
  - %s - 代表输出的内容是字符串
  - %.2f - 表示输出内容保留几位小数
- 使用format方法进行格式化输出
- 使用英文字母f""
  - 不支持python2

## python如何进行排序

- sort 排序，正序
- sort(reverse=True) 倒叙

## python如何去重

- list(set())

## python匿名函数

- 使用关键字：lambda表示匿名函数

- 匿名函数有个限制。就是只能有一个表达式，不用写return，返回值就是该表达式的结果
- 匿名函数的好处就是函数没有名字，不用但是函数名冲突。

## python中的yield用法

yield简单来说就是一个生成器，这样函数它记住上次返回时在函数中的位置，对于生成器第二次(或n次)调用跳转至该函数

## return和yield的区别

- return：在程序函数中返回某个值，返回之后函数不在继续执行，彻底结束

- yield：带有yield的函数是一个迭代器，函数返回某个值时，会停留在某个位置，返回函数值后，会在前面停留的位置继续执行，直到程序结束
- yield的函数返回一个generator对象给调用者；return返回一个值给调用者

## Linux常用命令

- ls 列出当前文件夹下的内容

- pwd 查看当前所在目录

- cd 切换目录，cd.. 返回上一层

- touch 创建文件

- mkdir 新建目录

- rm 删除文件 rm -r 目录名 删除目录 rm -f 强制删除

- cp 复制文件

- mv 移动文件、改名

- grep 搜索文本、文件名

- cat 显示文件完整内容 more 分屏显示文件内容 less 分屏显示文件内容

  head -n 打印前几行 tail -n 打印末尾几行

- top 动态实时显示cpu、内存、进程使用情况

- ps 列出进程 ps -ef ｜ grep xxx 查看xx进程

​		ps -a 列出所有进程

- kill 杀死进程 kill -9 pid 强制杀死某进程
- free 显示当前内存使用情况
- su 切换用户 sudo 管理员
- chmod 修改权限
- linux 三剑客 【grep、sed、awk】

## OSI 七层

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

顺口溜：（`物数网传会表应`）

## TCP连接为何需要三次握手

两次握手只能保证单向连接时畅通的。

只有三次握手才能确保双向都可以接受到对方的发送的数据

## TCP如何处理拥塞

- 慢启动
- 拥塞避免
- 快重传
- 快恢复

## TCP和UDP区别

- 基于连接与无连接
- 对系统资源的要求(TCP较多，UDP少)
- UDP程序结构比较简单
- 流模式与数据报模式
- TCP保证数据正确性，UDP可能丢包；TCP保证数据顺序，UDP不保证

## TCP/IP的区别

- 网络接口层
- 网络层
- 传输层
- 应用层：包括会话层、表示层、应用层

## HTTP1.0与2.0的区别

HTTP1.1

- 持久连接
- 请求管道化
- 增加缓存处理
- 增加Host字段、支持断点传输

HTTP2.0

- 二进制分帧
- 多路复用
- 头部压缩
- 服务器推送

## HTTP协议请求方式

- GET
- POST
- HEAD
- OPTIONS
- PUT
- DELETE
- TRACE
- CONNECT

## HTTP请求头包含哪些信息

- User-Agent：产生请求的浏览器类型
- Accept：客户端可识别的内容类型列表
- Host：请求的主机名，允许多个域名同处一个ip地址

## HTTP和HTTPS的区别

- HTTPS协议需要到CA申请证书，一般免费证书较少，需要一定的费用

- HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80 HTTPS是443
- HTTP的连接简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输比HTTP协议安全

## 对称加密和非对称加密的区别和原理

对称密钥加密是指加密和解密使用同一个密钥的方式；非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只能自己知道。

## 常见的状态码

1xx：请求处理中，请求已被接受，正在处理

2xx：请求成功，请求被成功处理 200 ok

- 201:请求已经被实现
- 202:服务器已接受请求，但尚未处理

3xx：重定向

- 301:永久性转移
- 302:暂时性转移
- 304:已缓存
- 305:请求者只能使用代理访问请求的网页
- 307:服务器目前从不同位置的网页响应请求

4xx：客户端错误

- 400:Bad Request,请求有语法问题；
- 403:拒绝请求；
- 404:请求失败，访问的资源未被在服务器上发现

5xx：服务端错误

- 500:服务器内部错误；
- 502:上游服务器接受到无效的响应
- 503:服务不可用

## Get与POST的区别

- Get一般用来从服务器上获取资源；POST一般用来创建资源；
- GET是幂等的，即读取同一个资源，总是得到相同的数据；POST不是幂等的；GET不会改变服务器上的资源，而POST会对服务器资源进行改变
- Get请求的数据会附在URL之后；Post请求会把提交的数据则放置在HTTP请求报文的请求体中
- POST的安全性比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而POST请求参数则被包装到请求体中，相对安全。
- GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。
- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET产生的URL地址可以被标记，而POST不会
- GET请求会被浏览器主动存储，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史里，而POST中的参数不会被保留
- GET请求在URL中传的参数长度有限制，而POST不会
- 对参数的数据类型，GET只能接受ASCII字符，而POST没有限制
- GET参数通过URL传递，POST放在Requestbody中

## Session、Cookie、token的区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上。而token是接口测试时的鉴权码，一般情况下登陆后才可以获取token，然后在每次请求接口时需要带上token参数。
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session，session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器性能，考虑到减轻服务器性能方面应当使用cookie
- 可以将登陆信息等重要信息存放在session；其他信息需要保存，例如头像，可以存放cookie

## 常用的测试方法

- 黑盒测试

不考虑内部结构，即具体代码的实现，检测软件的各个功能是否得以实现，确认软件功能的正确性，关注具体的客户端需求及软件功能

- 白盒测试

关注程序代码的具体细节，根据软件内部代码的逻辑结构来分析进行测试，关注代码的实现细节

- 灰盒测试

  - 静态测试：在不运行程序的情况下寻找代码中可能存在的错误，或者评估程序代码

  - 动态测试：实际运行被测程序，输入相应的测试用例，检查运行结果于预期结果的差异

  - 阿尔法测试：一个用户在开发环境下的受控测试，模拟实际操作环境如：内测

  - 贝塔测试：多个用户在实际使用环境下进行的测试，如公测

  - 回归测试：我们测出bug后，然后返还给程序员修改，程序员修改后，进行同样操作看能不能复现

## 测试用例设计方法

- 等价类划分：将全部输入数据合理划分成若干个等价类，在每一个等价类中取一个数据作为输入条件，分为有效等价类和无效等价类
- 边界值分析法：大量错误是发生在输入输出范围的边界上，选定测试用例时应该选取正好等于、刚刚大于、刚刚小于边界值作为测试数据
- 错误猜测法：基于经验和直接推测列举出程序中所有可能的错误和容易发生错误的特殊情况
- 因果图法：考虑输入条件之间相互组合，也考虑输出结果对输入条件的依赖关系
- 场景分析法：根据用户场景来模拟用户的操作步骤

## 软件测试阶段分类

- 单元测试

针对软件设计最小单位程序模块进行正确性检测

- 集成测试

在单元测试的基础上，将所有程序小模块组起来，进行有序的测试

- 系统测试

在系统的真实运行环境下，检查完整的程序系统是否可以和硬件、外设、网络和系统软件、支持平台等正确配置、连接。

- 验收测试

一般由供求双方共同达成，模拟用户实际运行的环境，对功能模块全面测试。

## 缺陷等级划分

- P0：致命【crash，死机，白屏】- 需要立即修复
- P1：严重【局限在一个模块，导致功能失常或异常退出】- 需要优先考虑
- P2：一般【模块功能全部失效】- 排队等待修复
- P3：建议【对该模块提出建议比如错别字等】- 有时间的时候修复

## 测试流程

需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试

## 缺陷的生命周期

新建bug--打开bug--修复bug--回归bug--关闭bug

## 软件测试的核心竞争力是什么

测试人员的核心竞争力在于提早发现问题，并能够发现别人无法发现的问题

- 早发现问题：问题发现越早，解决的成本越低。

## 测试项目具体工作

- 搭建测试环境
- 撰写测试用例
- 执行测试用例
- 写测试计划，测试报告
- 跟踪bug修改情况
- 执行自动化测试，编写脚本，执行，分析，报告
- 进行性能测试，压力测试，执行，分析，调优，报告

## Python的映射类型

`字典`

## 元祖列表字典区别

> 元组使用小括号`()`,列表使用方括号`[]`,字典使用`{}`

元祖：封闭的列表，一旦定义，就不可改变（添加、删除、修改）

列表：可以随意增加和删除任何东西 `append()` 添加`del()`删除

```python
#!/usr/bin/python
# 访问列表
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5, 6, 7 ]
 
print "list1[0]: ", list1[0]
# list1[0]:  physics
print "list2[1:5]: ", list2[1:5]
# list2[1:5]:  [2, 3, 4, 5]

# 更新列表
list = []          ## 空列表
list.append('Google')   ## 使用 append() 添加元素
list.append('Runoob')
print (list)
# ['Google', 'Runoob']

# 删除列表
list1 = ['physics', 'chemistry', 1997, 2000]
 
print list1
del list1[2]
print ("After deleting value at index 2 : ")
print (list1)
# ['physics', 'chemistry', 2000]
```

字典：key-value键值对的形式，键唯一，且不可变 `del` 删除字典 

```python
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
 
dict['Age'] = 8 # 更新
dict['School'] = "RUNOOB" # 添加
 
print "dict['Age']: ", dict['Age']
# dict['Age']:  8
print "dict['School']: ", dict['School']
# dict['School']:  RUNOOB

del dict['Name']  # 删除键是'Name'的条目
dict.clear()      # 清空字典所有条目
del dict          # 删除字典
```

## 进程 线程 协程

### 进程

- 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立。 
- 稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制。

### 线程

- CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享进程的所有资源。
- 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃。

### 协程

- 子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

## GIL

简而言之，python全局解释器锁或GIL是一种互斥锁，仅允许一个线程持有python解释器的控制权。

GIL是python的`全局解释器锁`，同一进程中假如有多个线程运行，一个线程再运行python程序的时候会霸占python解释器(加了一把锁即GIL)，使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。

一般来说我们通过锁来解决内存方面的问题

## 常见的web自动化元素定位方式

- id：根据id来获取元素，返回单个元素，id值一般是唯一的。
- name：根据元素的name属性定位
- tagName：根据元素的标签名定位
- className：根据元素的样式class值定位
- linkText：根据超链接的部分
- partialLinkText：css选择器定位
- xpath

## App性能测试的指标

- 内存
- cpu
- 流量
- 电量
- 启动速度
- 滑动速度、界面切换速度
- 与服务器交互的网络速度

## Web测试和App测试的不同点

### 系统架构方面：

web项目，一般都是B/S架构，基于浏览器的

app项目，则是C/S的，必须要有客户端，用户需要安装客户端

web测试只要更新服务器端，客户端就同步会更新；app项目则需要客户端和服务器都更新。

### 性能方面：

web页面主要会关注响应时间；

app需要关注流量、电量、cpu、gpu、内存等

### 兼容方面：

web是基于浏览器的，所以更倾向浏览器和电脑硬件，电脑系统的的兼容，

app测试则要看分辨率，屏幕尺寸，还要看设备系统；

web测试是基于浏览器的所以不必考虑安装卸载，

app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件；

app还有一些专项测试：如网络、适配性

## App H5 Web 小程序测试的区别

- web测试：
  - 功能测试：刷新、回退、前进、翻页、页面加载、url
  - 兼容测试：不同的浏览器内核进行测试
  - 性能测试：web项目需监测响应时间、cpu、内存
- H5测试：
  - 功能测试：刷新、回退、前进、翻页、页面加载、url、界面测试
  - 性能测试：页面加载时间、弱网环境和服务端的压测
  - 兼容性测试：浏览器兼容、系统版本兼容、分辨率兼容
- app测试：
  - 界面测试：分辨率、屏幕尺寸、兼容性
  - 设备系统：安卓/ios/鸿蒙 等不同的系统
  - 专项测试：
    - 干扰测试：中断、来电、短信、关机、重启
    - 弱网测试：2g、3g、4g、5g、wifi网络状态差以及丢包
    - 安装、更新、卸载

## Fiddler抓包

### 断点方式有哪些

- Before Requests：在请求时，没有达到服务器之前设置断点。
- After responses：服务器响应之后，在fiddler将响应传回给客户端之前。
- Disabled 取消断点

### 为什么要设置断点

> 进行接口测试时，拦截和修改数据，测后端功能。比如：某图书网小说售价100元，进行网页前端的功能测试时，只能输入100元进行购买！但是通过fiddler抓包工具可以拦截，修改数据。防止跳过前端输入框验证，然后修改数据，输入-100元进行购买，这样的话，不仅买了小说，账户余额还增加100元。这样说明后端接口不对

### 怎么设置断点

- Rules>>Automatic Breakpoints>>Before Requests(After Response) -- 全局断点

- 在命令行输入:（单个断点）

  1.bpu 接口链接 然后回车 --before request

  2.bafter 接口链接 然后回车 -- after response

### 拦截来自某个网址所有请求

在命令行输入：bpu 网址

### 设置抓取https请求

Tools-->Options-->HTTPS，勾选CaptureHTTPS CONNECTs、Decrypt HTTPS tranffic、Ignore serve certificate errors 点击ok，会弹出证书确认即可

### 设置抓取手机app的包

1、配置移动端证书检查，Tools-->Connections-->勾选Allow remote co mputers to connect

2、手机设置方式，配置代理输入ip+端口 登陆ip地址下载证书安装即可

## Charles抓包

- 抓APP发送的数据包，首先要进行设置，Proxy->Proxy Settings默认端口8888->然后查看本机IP->然后和fiddler代理一样的步骤
- 过滤网络请求：在Sequence中的Filter填入需要抓的网址
- Https请求抓包：需要安装证书，Help->SSL Proxying->Install Charles Root Certificate 然后需要抓手机https网址需要在浏览器打开`http://chls.pro.ssl`网址下载证书安装即可

## Web性能测试工具

### Jmeter测试元件的执行顺序

配置元件->前置处理器->定时器->取样器->后置处理器->断言->监听器

### 什么是JMeter断言？断言的类型有哪些？

断言有助于验证被测服务器是否返回了预期结果。

JMeter中常见断言：

- 响应断言
- 持续时间断言
- 大小断言
- XML断言
- HTML断言
- JSON断言

### 列出几个JMeter监听器？

- 集合报告
- 汇总报告
- 查看结果数
- 图形结果
- BeanShell Listener

### 解释计时器(Timer)在JMeter中的作用是什么？

在计时器的帮助下，JMeter可以延迟线程发出的每个请求之间的时间。可以解决服务器的过载问题。

### 整体流程

JMeter的操作的整体流程，首先创建一个线程组，指定并发的线程数量，然后指定的要测试的接口，创建相应的监听器，比如表格结果，结果数和聚合报告信息，通过监听器来监听测试是否通过接口是否存在什么问题

其中结果树中可以检测到整体的请求信息，就拿Http请求这种来讲，其实就是整个http协议的所有信息，包括请求头，请求参数，请求路径，还有响应头，响应结果等信息，对于表格查看结果，可以看到每个请求的简单信息，本次请求的时间，以及平均时间。

在聚合报告中，我们就可以看到整体的信息了。比如可以看到平均响应时间，90%Line也就是90%的用户请求低于的时间。还有吞吐量TPS，还有错误率，还有流量来计算吞吐量。

吞吐量=（请求数）/（总时间）

### JMeter参数化

做压力测试时。我们经常需要替换参数，在JMeter中，可以在测试计划中设置全局参数，可以设置用户参数，还可以在前置处理器中设置用户参数。在进行多线程并发的时候，如果需要多个参数，可以使用csv配置元件。

### JMeter连接手机做性能测试

- 启动Jmeter
- 添加线程组--逻辑控制器--录制控制器
- 添加测试计划--非测试元件--HTTP代理服务器
- 手机就类似像fiddler一样配置wifi+端口
- 启动代理服务器
- 进行操作，此时JMeter就开始录制
- 删除不必要的请求
- 保存jmx脚本
- 添加观察结果数
- 回放

### JMeter中的聚合报告每个指标代表什么？

- Lable：每个JMeter 的element都有一个Name属性

- #Samples：发出多少个请求
- Average：平均响应时间(单个request的平均响应时间)
- Media：中位数，50%用户的响应时间
- 90%Line～99%Line：90%～99%用户的响应时间
- Min：最小响应时间
- Maxmun：最大响应时间
- Error%：测试中出现的错误率
- Throughput：吞吐量——每秒完成的请求数
- Received KB/src：每秒从服务器端接收到的数据量
- Sent KB/src：每秒从客户端发送的请求和数量

## web测试，怎么写？

Web测试主要从下面几个大方向考虑

功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等

性能测试，考虑链接速度测试，以及负载测试，例如：web应用系统能允许多少个用户同时在线？如果超了这个数量，会出现什么现象？web应用系统能否处理大量用户对同一个页面的请求？还有压力测试，可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等。

- 现在web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等
- web应用系统是否有超时的限制，也就是说，用户登陆后一定时间内，没有点击任何页面，是否需要重新登陆才能正常使用。
- 为了保证web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。
- 当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。
- 服务端的脚本常常构成安全漏洞，有些漏洞又常常被黑客利用。所以。还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。

## 如何测试手机开机键

- 功能测试：

按下开机键，屏幕是否亮起。

- 性能测试

按下开机键，屏幕是否在规定时间内亮起

- 压力测试

连续多次按下开机键，观察屏幕是否一直亮起，到多久时间失灵

- 健壮性测试

给一个中了病毒的手机或淘汰许久的老机子，安歇开机键观察屏幕能否亮起

- 可靠性测试

连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数

- 可用性测试

开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便

## 印象深刻的bug，接口测试出现bug的原因有哪些？

- 特殊值处理不当导致程序异常退出或者崩溃
- 类型边界溢出，导致数据独处写入不一致
- 取值边界外未返回正确的错误信息
- 权限为处理，可以访问其他用户的信息
- 逻辑校验不完善，可以利用漏洞获取非正当利益
- 状态处理不当，导致逻辑出现错误
- 数组类型item个数为0或者item重复时程序异常退出

## 压力测试如何做？

- 首先对要测试的系统进行分析，明确需要对那一部分做压力测试，比如秒杀，支付。
  - 第一种方式可以通过写脚本产生压力机器人对服务器进行发包收报操作
  - 第二种借助一些压力测试工具，Jmeter，LoadRunner
- 如何对这些压力测试点进行正确的施压
  - 需要压力测试工具或者其他方法录制脚本，模拟用户的操作
- 对测试点设计多大的压力比较合适
  - 需要明确压力测试限制的数量，即用户并发量
- 测试结束后如何通过这些数据来定位性能问题
  - 通过测试可以得到吞吐量，平均响应时间等数据，这个数据的背后是整个后台处理逻辑综合作用的结果，这时候就可以先关注系统CPU，内存，然后对比吞吐量，平均响应时间达到瓶颈时这些数据的情况，然后就能明确性能问题是系统的那一块造成的。

## 功能测试和接口测试是怎么做的？

- 功能测试

首先制定测试计划，然后进行测试设计，将在测试阶段指定的测试活动分解，进而细化，为若干个可执行程序的子测试过程，然后执行测试，按照测试计划使用测试用例对待测项目进行逐一的，详细的排查分析评估，最后对测试结果进行统计和分析

- 接口测试

接口测试也是属于功能测试，所以跟我们以往的功能测试流程并没有太大的区别，测试流程依旧是: 1.测试接口文档(需求文档) 2.根据接口文档编写测试用例(用例编写完全可以按照以往规则来编写，例如等价划分，边界值等设计方法) 3.执行测试，查看不同的参数请求，接口的返回的数据是否达到预期。

## 测试工具用过哪些？

- 自动化测试工具用过selenium和uiautomator2

- 性能测试工具用过Jmeter

## 设计一个微信朋友圈点赞的用例

- 功能测试：

点赞某条朋友圈，验证是否成功

- 接口测试：

点赞朋友圈，验证朋友能否收到提示信息

- 性能测试

点赞朋友圈，是否在规定的时间显示结果，是否在规定的时间在朋友手机上进行提示

- 兼容性测试

在不同的终端，比如ipad，手机上点赞朋友圈，验证是否成功

## 前端和后端吵起来都说不是自己的问题，作为测试的我们，该怎么办？

此时应该找技术leader拍板或leader们基于安全性、性能、可测试性、可维护性讨论敲定一个解决方案，做到开发环境方便开发，线上环境少配置，少依赖，少出错机会。

## 如何对登陆界面进行测试

::: details

- 黑盒测试方法

输入正确用户名和密码，验证是否登陆成功

输入正确的用户名和错误的密码，验证是否登陆失败并且提示信息正常

输入未注册的用户名和任意密码，验证是否登陆失败并且提示信息正确

用户名和密码都为空，验证是否登陆失败并且提示信息正确

用户名和密码两者之一为空

若启用了验证码，输入正确的用户名验证码是否能登陆成功

输入正确用户名和密码，错误的验证码，能否登陆成功并且提示信息正确

用户名和密码是否大小写敏感

页面上的密码框是否加密显示

后台系统第一次创建的用户重新登陆时是否提示修改密码

忘记用户名和忘记密码的功能是否可用

前端功能是否根据要求限制用户名和密码的长度

点击验证码图片是否可以更换验证码，更换后验证码是否可用

刷新页面是否会刷新验证码

如果验证码具有实效性，分别验证时效内和时效外验证码的有效性

用户登陆成功但是会话超时后是否重定向到用户登陆界面

不同级别的用户登陆系统后的权限是否正确

页面默认定位焦点是否定位到用户输入框中

快捷键tab和回车键是否可以正常使用

- 安全

用户密码后台存储是否加密

用户密码在网络传输过程中是否加密

密码是否具有有效期，密码有效期到期后是否提示修改密码

不登陆的时候直接在浏览框中输入登陆界面后url地址，是否重新定位到登陆界面

密码输入框是否不支持复制粘贴

页面密码输入框中输入的密码是否可以在页面源码模式下被查看

用户名和密码输入框中输入xss跨站脚本攻击字符串验证系统的行为是否被篡改

连续多次登陆失败后系统是否会阻止用户后续的尝试

统一用户在同一终端的多种不同的浏览器上登陆，验证登陆功能的互斥性是否符合设计预期

同一用户先后在不同终端的浏览器上登陆用户名和密码输入框中输入典型sql注入攻击字符串验证系统的返回页面

- 性能测试

单用户登陆的响应界面是否符合预期

单用户登陆时后台请求数量是否过多

高并发场景下用户登陆的响应界面是否符合预期

高并发场景下服务端的监控指标是否符合预期

高集合点并发场景下是否存在资源死锁和不合理的资源等待

长时间大量用户连续登陆和退出，服务端是否存在内存泄漏

- 兼容测试

不同浏览器下验证登陆功能的页面显示和功能正确性

相同浏览器的不同版本下验证登陆功能的页面显示和功能正确性

不同终端的不同浏览器下验证登陆功能的页面显示和功能正确性

不同分辨率下的页面显示和功能正确性

- 弱网测试

网路切换和网络延迟时登陆界面是否正常

是否支持第三方登录

是否可记住密码，记住的密码是否加密

:::

## 淘宝购物车测试用例（web端）

- 梳理淘宝购物车的业务流程如下：
  - 进入购物车--加商品到购物车--编辑购物车--选择商品--提交订单
- 冒烟测试：
  - 加入购物车--进入购物车--选择商品提交订单--跳转到订单页面
- 进入购物车入口
  - 底部菜单栏，点击跳转购物车
  - 商品详情低部去购物车结算，点击跳转到购物车
- 用户购物车的权限
  - 已经登陆的用户，点击购物车，可以进行购物车相关的操作
  - 未登陆的用户，点击进入购物车，提示未登陆，并弹出登陆界面
- 添加商品到购物车，查看购物车显示
  - 添加一件商品到购物车，观察购物车显示，规则、信息描述等是否正常
  - 添加同一个商家的多件商品到购物车，观察购物车显示正常
  - 添加不同商家的多件商品到购物车，观察购物车显示正常
  - 商品、商家名称和描述太长，UI显示正常
  - 点击商品链接可以打开商品详情页
  - 货物状态
    - 有货，并显示商品的数量
    - 无货，无法勾选选择，并调试重新选择商品的规格
    - 下架，移到失效宝贝，可以找相似的商品
- 购买数量增减操作
  - 数量范围
    - 有效：1/后台最低限购梳理～库存/最大限购数量
    - 无效：0/大于库存，大于最大限购数量，小于最低限购数量，检查是否有友好的报错信息
  - 数据类型
    - 有效：整数字
    - 无效：非数字，可以从字母、字符、中文里选择一个代表测试；小数、负数，检查输入是否有提示信息
  - 必填项：输入数量为空/或者空格，检查是否有报错信息并友好
- 商品支持删除
  - 点击删除是否有提示信息，可以确认和取消按钮可用
  - 删除后，商品不显示在购物车列表；商品总件数减1，总价检查更新正确
- 商品支持移入收藏夹
  - 点击移入收藏夹后，购物车里不显示商品
  - 收藏夹里增加商品显示正常
- 选择功能
  - 单选商品，合计里的统计数据正常，并可以取消勾选
  - 多选商品，合计里的统计数据正确，并可以取消勾选
  - 全选，合计里的统计数据正确，并可以取消勾选；反勾选一额商品，全选框状态变化
- 点击去结算
  - 点击结算，可以跳转到下一个页面，金额和数量都是正确的
- 空购物页面
  - 空购物车检查页面显示，可以点击"去购物"跳转首页进行购物
- 功能交互
  - 优惠卷，有优惠卷的使用规则，价格和限制是否正确
  - 订单处理，跟订单功能模块交互
  - 登陆功能模块交互

## 淘宝购物车测试用例（app端）

- 支付中断
  - 电话中断
  - 网路中断
  - 闹钟中断
  - 插拔耳机中断
- 网络测试
  - 2G、3G、4G、5G、wifi下都可以正常操作
  - 进行网络切换，功能正常
- 弱网测试
  - 购物车结算的时候，不会重复提交订单
  - APP不会闪退 崩溃，而且页面提示友好

## 淘宝购物车非功能测试点

- 界面
  - 验证界面的美观，拍板和错别字等
- 兼容性
  - 移动端的淘宝购物车
    - 考虑测试手机移动端兼容性，比如手机型号、尺寸、系统、分辨率
    - 考虑系统版本的兼容，主流系统版本需要测试覆盖
    - 考虑不同屏幕大小及分辨率的兼容性测试
  - web端的淘宝购物车
    - 考虑浏览器的兼容性，不同的内核版本的浏览器
    - 从同一个内核版本的浏览器里选择主流的浏览器进行测试
- 易用性
  - 测试站在用户的角度考虑用户体验，使用是否方便等
- 性能
  - 大量用户同时操作等，一般借助工具或者代码进行测试
- 安全
  - 验证用户敏感信息是否加密，是否可被篡改；通过一些工具进行安全扫描，检查是否有安全漏洞；或者采用一些其他的手段进行专门的安全测试

## 性能测试有哪些指标？对一个登陆功能做性能测试，有哪些指标？如何测出可同时处理的最大请求数量？

- 性能测试常用指标

1、吞吐量：每秒钟系统能够处理的请求数，任务数

2、响应时间：服务处理一个请求或一个任务的耗时

3、错误率：一批请求中结果出错的请求所占比例

从服务器的角度看，性能测试关注cpu，内存，服务器负载，网络，磁盘I/O

- 对登陆功能做性能测试

1、单用户登陆的响应界面是否符合预期

2、单用户登陆时后台请求的数量是否过多

3、高并发场景下服务端的监控指标是否符合预期

4、高集合点并发场景下是否存在资源死锁和不合理的资源等待

5、长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏

- 如何测可同时处理最大请求数量

可以采用性能测试工具(WeTest服务器性能)，能提供10W+以上的并发量，测出服务器模型最大并发

## 数据库

### 基本的SQL语句

::: details

选择：select * from 表名 where 范围

插入：insert into 表名(表1,表2) values (value1,value2)

删除：delete from 表名 where 范围

更新：update 表名 set 表1=value1 where 范围

查找：select * from 表名 where 表名 like "%value1%"

排序：select * from table1 order by fidld1,field2[desc、asc]

总数：select count as totalcount from table1

求和：select sum(field1) as sumvalue from table1

平均：select avg(field1) as avgvalue from table1

最大：select max(field1) as maxvalue from table1

最小：select min(field1) as minvalue from table1

左连接：select * from 表1 left join 表2 where 表1.id = 表2.id 

右链接：select *  from 表1 right join 表2 where 表1.id = 表2.id

内连接：select * from 表1 inner join 表2 on 表1.id = 表2.id

:::

## mysql 左连接和右连接和内连接区别？

- 左连接

在`left join`左边的表里面数据全部被查出来，右边的数据只会查处符合`on`后面的符合条件的数据，不符合的会用`null`代替

- 右连接

与`left join`正好相反，右边的数据会全部查出来，左边只会查出`on`后符合条件的数据，不符合会用`null`代替

- 内连接

相当于左连接与右连接的合并，去掉所有的`null`的数据行，剩下的就是查询出来的数据(两边都要必须满足)

## Sql的优化

- sql尽量使用索引，而且查询要走索引
- 对sql语句优化

## 索引的优缺点，什么时候使用索引，什么时候不使用索引

- 索引最大的好处就是提高查询效率
- 缺点就是更新数据时效率低，因为要同时更新索引
- 对数据进行频繁查询建立索引，如果要频繁更改数据不建议使用索引

## having 和 where 区别

- 分组筛选的时候用having，其他情况用where

- where 不能放在 group by 后面
- having 是跟 group by 一起用；用group by不一定有having
- where 是一个约束声明，使用where来约束来自数据库的数据，where是在结果返回之前起作用的，且where中不能使用聚合函数
- having 是一个过滤声明，是在查询返回结果以后对查询结果进行过滤操作，在having中可以使用聚合函数

## where 子句 和 having 子句却别

- where 子句

  `where`子句仅用于从`from`子句中返回值，`from`子句返回每一行数据都会用`where`子句中的条件进行判断筛选。`where`子句中允许使用比较运算符（`>，<，<=，>=，<>，!= ｜`等）和逻辑运算符(`and，or，not`)

- having 子句

  `having` 子句通常与 `order by` 子句一起使用。因为 `having` 的作用是对使用`group by` 进行分组统计后的结果进行进一步筛选

## 死锁怎么解决

`找到进程号，kill进程`

## redis跟sql有什么区别？

- 从类型上

mysql是关系型数据库；redis是缓存数据库

- 从作用上

mysql用于持久化存储数据到硬盘，速度比较慢；redis用于存储使用比较频繁的数据到缓存中，速度比较快

##  某个表格存着s_name subject score 三个字段，比如某一行是 张三 数学 76，现在要选取出所有科目成绩都大于80分的学生名字，请写出sql语句

```sql
select s_name from table_name where s_name
not in (select s_name from table_name) where score < 80
```

## 写出sql语句：数据库统计总成绩取前十名的学生

```sql
select * from 
(select * from stu order by grade desc)
limit 10;
```

## 请问count和sum的区别，以及count(*)和count(列名)的区别

- count和sum区别

求和用累加sum()，求行的个数用累计count

- count(*)和count(列名)区别

count(*) 包括了所有的列，在统计结果的时候不会忽略列值为null

count(列名)只包括列名那一项，会忽略列值为空的计数

## 接口测试怎么测

- 业务功能测试

正常场景、异常场景

- 边界分析测试

  - 业务规则边界分析

  - 输入输出参数边界值分析

    - 覆盖所有的必选参数

    - 组合可选参数

    - 参数有、无或null

    - 参数的顺序、个数、类型

    - 参数类型数值大小，输入的数值范围

    - 参数数字串长短：null-max-max+1

    - 参数包含特殊字符

- 参数组合测试
- 异常情况测试
  - 重复提交
  - 并发测试
  - 事务测试
  - 分布式测试
  - 环境异常
  - 大数据测试
    - 同时处理大批数据的测试
    - DB数据量很大时，测试DB操作
- 性能测试
  - 响应时间
  - 吞吐量
  - 并发数
  - 服务器资源使用率
    - CPU
    - 内存
    - IO
    - 网络
- 安全测试
  - 敏感信息是否加密
    - 前后端数据传输是否加密
    - 日志信息是否加密
  - sql注入

## 分析bug是前端还是后端的

先抓包看请求报文，对着接口文档，看请求报文有没有问题，有问题就是前端发的数据不对，请求报文没问题，就看返回报文，返回的数据不对，那就是后端开发的问题

## 接口自动化面试题

- JSON和字典的区别？
  - json是一种轻量级的数据交换格式；字典是python中的数据类型
  - json本质上是字符串，按照`key:value`键值对格式的字符串
  - 在json中空值用Null表示；在字典中空值用None表示
- 字典和列表有什么区别？
  - 列表任意对象的有序集合；字典是一个关联数组(key-value)
  - 列表通过偏移读取，组成列表的值叫元素，每一个元素被标志一个索引；字典中没有特定的顺序，以键为象征
  - 列表可变长度，异构以及任意嵌套；字典是可变、异构、任意嵌套

- 字典怎么遍历值？
  - 使用字典的键进行遍历
  - 利用enumerate()函数取出键的序号和键名
  - 利用dict.key()方法来获取字典中所有的键
  - 利用dict.values()方法来获取字典中所有的值
  - 利用dict.items()方法来获取字典中所有的键值对


- 测试的数据你放在哪？
  - 对于账号密码，这种全局的参数，可以用命令行参数，单独抽出来，写在配置文件里(ini)
  - 对于一些一次性消耗的数据，比如注册，每次注册不一样的数，可以用随机函数生成
  - 对于一个接口有多组测试的参数，可以参数化，数据放yaml，text，json，excel都可以
  - 对于可以反复使用的数据，比如订单的各种状态需要造数据的情况，可以放到数据库，每次数据初始化，用完后在清洗
  - 对于邮箱配置的一些参数，可以用ini配置文件
  - 对于全部都是独立的接口项目，可以用数据驱动方式，用excel/csv管理测试的接口数据
  - 对于少量的静态数据，比如一个接口的测试数据，也就2-3组，可以写到py脚本的开头

- 参数化
- 下个接口请求参数依赖上个接口返回数据
  - 不同的接口封装成不同的函数或方法，需要的数据return出来，用一个中间变量a去接受，后面的接口传a就可以了
- 依赖于登陆的接口如何处理(token和session的管理)
  - 登陆接口依赖token的，可以先登陆后，token存在一个yaml或者json，或者ini的配置文件里面，后面所有的请求去拿这个数据就可以全局使用了

- 依赖第三方的接口如何处理
  - 需要自己去搭建一个mock服务，模拟接口返回数据
- 接口产生的垃圾数据如何清理
  - 造数据和数据清理，需用python连数据库，做增删改查的操作，测试用例前置操作，setUp做数据准备，后置操作，tearDown做数据清理

## Seleium 面试题

- 如何判断一个页面上元素是否存在

  - 方法一：用try...except

  - 方法二：用elements定义一组元素方法

  - 方法三：结合WebDriverWait和expected_conditions判断
- 如何提高脚本的稳定性
  - 不要复制xpath，自己写相对路径，多用id为节点查找
  - 定位没问题的话，影响元素那就是等待了，sleep等待尽量少用
  - 定位元素方法重新封装，结合WebDriverWait和expected_conditions判断元素方法，自己封装一个定位元素方法
- 如何定位动态元素
  - 如果id为动态的，那就不要用id定位，可以用name定位
- 如何通过子元素定位父元素
  - 通过父元素定位子元素，通过二次定位来找到该元素
- 怎么提升运行效率？
  - 使用配置更高的电脑，选择更快的网络环境
  - 能直接访问网址的就不要一步一步点击
  - 不要盲目增加sleep，尽量使用显示等待
  - 可以考虑分布式执行(多线程)


## App面试题

- 什么是activity
  - Activity是安卓四大组件之一，也是平时我们用过最多的一个组件，可以用来显示view
- Android四大组件
  - Activity、BroadcastReceiver广播接收器、ContentProvider内容提供者、Service服务
- App出现ANR，是什么原因导致的？
  - 主线程执行了耗时操作，比如数据库操作或网络编程
  - 其他进程占用了CPU导致本进程得不到CPU时间片，比如其他进程的频繁读写操作可能会导致这个问题
  - 硬件操作
  - 调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候
  - service binder的数量达到上限
- App出现crash原因有哪些？
  - 内存管理错误：可能是可用内存过低，app所需的内存超过设备的限制，app跑不起来导致App crash，或内存泄漏，程序运行的时间过长，所占用的内存越大，最终用尽全部内存，导致整个系统崩溃。
  - 程序逻辑错误：数组越界、堆栈溢出、并发操作、逻辑错误
  - 设备兼容：由于设备多样性，app在不同的设备上可能会有不同的表现
  - 网络因素：可能是网速欠佳，无法达到app所需的快速响应时间，导致app crash
- App对于不稳定偶现出现anr和crash时候你是怎么处理的？
  - app开发保存错误日志到本地
  - 实时抓取(adb 命令)
    - adb logcat | find "app包名" > d:\crash.txt
  - 第三方sdk统计工具

## pytest有哪些断言方式

- assert xx：判断xx为真
- assert not xx：判断xx不为真
- assert a in b：判断b包含a
- assert a == b：判断a等于b
- assert a != b：判断a不等于b

## pytest中的fixture调用方式

- 函数或类里面方法直接传fixture的函数参数名称
- 使用装饰器@pytest.mark.usefixtures()修饰需要运行的用例
- 叠加usefixture

## 车载测试

- 什么是CAN网络
  - CAN是控制局域网络的简称，目前普遍运用在汽车网络
- CAN网络的优势
  - 开放的标准
  - 低成本
  - 高速实时传递，数据传输更安全可靠
  - 适用于各种车辆
- CAN网关的基本功能包括：
  - 连接不同波特率的CAN总线/LIN总线以实现CAN网络的网关中继功能
  - 诊断报文/非诊断报文转发
  - 诊断防火墙管理
  - 节点在线监控
  - 巡航控制器开关检测
  - 脚踏板位置检测
  - 网关休眠与唤醒管理
  - ECU升级/网关升级
  - 电压管理

- CAN/LIN/FlexRay是什么？
  - 

## 自动驾驶仿真

- 仿真测试能把大量自动驾驶开发和测试的成本转化为GPU的物料成本和工程师的知识经验之本
- 仿真场景作用
  - 提高对原始数据的提取以及转化效率
  - 方便构建冗余度低的场景体系
  - 方便不同场景体系之间的比较以及场景交换
  - 减轻第三方测试时的多余工作
- 功能场景-逻辑场景-具体场景
  - 功能场景：被测车在前车道运行，在被测车前方有前车加速运行，被测车跟随前车行驶
  - 逻辑场景：自车车速，前车车速以及加速度，自车与前车距离等参数，每个参数都有一定的取值范围和分布特性，参数之间可能还存在的相关性
  - 具体场景：需要转换计算机可理解的语言即场景语言才能发挥作用，场景语言时一种可用以描述自动驾驶系统待处理的外部环境的计算机可解析的形式化语言
- 静、动态场景内容
  - 概念：将元素分为静态元素和动态元素两部分
  - 静态场景
    - 道路、基础交通设施(交通标线、交通标识、交通信号灯以及抽象的交通规则等)、天气、光照、其他建筑物基础设施等
  - 动态场景
    - 交通行为
    - 交通参与者(重卡、轻卡、乘用车、电动车、行人)
    - 带时间戳的轨迹数据、基于行为分类的数据(跟车、换道)
    - 处理交互性
- 仿真软件-被测对象-通信环境
  - 交通流仿真软件、动力学仿真软件



