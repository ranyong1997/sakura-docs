---
date: "2021/12/02"
categories: [面经]
stick: true
tag: [面试经历]
---

# 面经

## 自我介绍

面试官您好，我叫xx，来自于xxx。做软件测试工作已经有x年了。在期间做了不少的项目，也积累了不少的测试经验，能够独立完成软件测试的测试工作，主要做过功能测试、app专项测试和接口测试方面的工作。对于linux、fiddler、jmeter熟悉。也用过jmeter做过一些性能测试。平常喜欢健身和摄影，这就是我一个简单的自我介绍，您看，我这边还需要什么补充吗？

## 深浅拷贝

浅拷贝：构造一个新的集合对象，用原始对象中找到的子对象的引用来填充它，复制过程不会递归，不会创建子对象的副本。【拷贝了引用，并没有拷贝内容】

深拷贝：构造一个集合对象，递归的用在原始对象中找到的子对象的副本来填充它，创建原始对象及其所有子对象完全独立的克隆。【进行所有的拷贝】

## is和==的区别

`is`判断两个对象的内存地址是否相同 而`==`判断两个对象的值是否相同`==`本质是（`equal()`）

## 装饰器

本质上是一个嵌套函数，接收被装饰的函数(`func`)作为参数，并返回一个包装过的函数，以实现不影响函数的情况下添加新的功能。

## 闭包

如果一个外函数中定义一个内函数，且内函数内引用到了外函数的变量，这时外函数通过`return`返回内函数的引用时，会把定义时设计到的外部引用变量与内函数打包成一个整体，即闭包。

## python的内存管理机制

Python中的垃圾回收主要以`引入计数`为主，再引入`标记`、`清楚`、`分代为辅`来解决循环引入的问题。

一个对象被引入时，引用计数加1，当对象被del时，引入计数减1，为0时，对象就被清除。

## __new__和init的区别

- 首先用法不同，`__new__()`用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；
  - `__init__()`用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。
  - `__new__()`在`__init__()`之前被调用。如果`__new__()`创建的是当前类的实例，会自动调用`__init__()`函数，通过return调用`__new__()`的参数cls来保证当前类实例
- 其次是返回值不同，`__new__()`必须有返回值，返回实例对象；
  - `__init__()`不需要返回值。

## Linux常用命令

- ls 列出当前文件夹下的内容

- pwd 查看当前所在目录

- cd 切换目录，cd.. 返回上一层

- touch 创建文件

- mkdir 新建目录

- rm 删除文件 rm -r 目录名 删除目录 rm -f 强制删除

- cp 复制文件

- mv 移动文件、改名

- grep 搜索文本、文件名

- cat 显示文件完整内容 more 分屏显示文件内容 less 分屏显示文件内容

  head -n 打印前几行 tail -n 打印末尾几行

- top 动态实时显示cpu、内存、进程使用情况

- ps 列出进程 ps -ef ｜ grep xxx 查看xx进程

​		ps -a 列出所有进程

- kill 杀死进程 kill -9 pid 强制杀死某进程
- free 显示当前内存使用情况
- su 切换用户 sudo 管理员
- chmod 修改权限
- linux 三剑客 【grep、sed、awk】

## OSI 七层

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

顺口溜：（`物数网传会表应`）

## TCP连接为何需要三次握手

两次握手只能保证单向连接时畅通的。

只有三次握手才能确保双向都可以接受到对方的发送的数据

## TCP如何处理拥塞

- 慢启动
- 拥塞避免
- 快重传
- 快恢复

## TCP和UDP区别

- 基于连接与无连接
- 对系统资源的要求(TCP较多，UDP少)
- UDP程序结构比较简单
- 流模式与数据报模式
- TCP保证数据正确性，UDP可能丢包；TCP保证数据顺序，UDP不保证

## HTTP1.0与2.0的区别

HTTP1.1

- 持久连接
- 请求管道化
- 增加缓存处理
- 增加Host字段、支持断点传输

HTTP2.0

- 二进制分帧
- 多路复用
- 头部压缩
- 服务器推送

## HTTP和HTTPS的区别

- HTTPS协议需要到CA申请证书，一般免费证书较少，需要一定的费用

- HTTP时超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP是80 HTTPS是443
- HTTP的连接简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输比HTTP协议安全

## 对称加密和非对称加密的区别和原理

对称密钥加密是指加密和解密使用同一个密钥的方式；非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只能自己知道。

## 常见的状态码

1xx：请求处理中，请求已被接受，正在处理

2xx：请求成功，请求被成功处理 200 ok

3xx：重定向，301:永久性转移；302:暂时性转移；304:已缓存

4xx：客户端错误，400:Bad Request,请求有语法问题；403:拒绝请求；404:客户端 所访问的页面不存在

5xx：服务端错误，500:服务器内部错误；503:服务不可用

## Get与POST的区别

- Get一般用来从服务器上获取资源；POST一般用来创建资源；
- GET是幂等的，即读取同一个资源，总是得到相同的数据；POST不是幂等的；GET不会改变服务器上的资源，而POST会对服务器资源进行改变
- Get请求的数据会附在URL之后；Post请求会把提交的数据则放置在HTTP请求报文的请求体中
- POST的安全性比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而POST请求参数则被包装到请求体中，相对安全。
- GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

## Session、Cookie、token的区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上。而token时接口测试时的鉴权码，一般情况下登陆后才可以获取token，然后在每次请求接口时需要带上token参数。
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session，session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器性能，考虑到减轻服务器性能方面应当使用cookie
- 可以将登陆信息等重要信息存放在session；其他信息需要保存，例如头像，可以存放cookie

## 常用的测试方法

- 黑盒测试

不考虑内部结构，即具体代码的实现，检测软件的各个功能是否得以实现，确认软件功能的正确性，关注具体的客户端需求及软件功能

- 白盒测试

关注程序代码的具体细节，根据软件内部代码的逻辑结构来分析进行测试，关注代码的实现细节

- 灰盒测试

  - 静态测试：在不运行程序的情况下寻找代码中可能存在的错误，或者评估程序代码

  - 动态测试：实际运行被测程序，输入相应的测试用例，检查运行结果于预期结果的差异

  - 阿尔法测试：一个用户在开发环境下的受控测试，模拟实际操作环境如：内测

  - 贝塔测试：多个用户在实际使用环境下进行的测试，如公测

  - 回归测试：我们测出bug后，然后返还给程序员修改，程序员修改后，进行同样操作看能不能复现

## 测试用例设计方法

- 等价类划分：将全部输入数据合理划分成若干个等价类，在每一个等价类中取一个数据作为输入条件，分为有效等价类和无效等价类
- 边界值分析法：大量错误是发生在输入输出范围的边界上，选定测试用例时应该选取正好等于、刚刚大于、刚刚小于边界值作为测试数据
- 错误猜测法：基于经验和直接推测列举出程序中所有可能的错误和容易发生错误的特殊情况
- 因果图法：考虑输入条件之间相互组合，也考虑输出结果对输入条件的依赖关系。
- 场景分析法：根据用户场景来模拟用户的操作步骤

## 软件测试阶段分类

- 单元测试

针对软件设计最小单位程序模块进行正确性检测

- 集成测试

在单元测试的基础上，将所有程序小模块组起来，进行有序的测试

- 系统测试

在系统的真实运行环境下，检查完整的程序系统是否可以和硬件、外设、网络和系统软件、支持平台等正确配置、连接。

- 验收测试

一般由供求双方共同达成，模拟用户实际运行的环境，对功能模块全面测试。

## 缺陷等级划分

- P0：致命【crash，死机，白屏】- 需要立即修复
- P1：严重【局限在一个模块，导致功能失常或异常退出】- 需要优先考虑
- P2：一般【模块功能全部失效】- 排队等待修复
- P3：建议【对该模块提出建议比如错别字等】- 有时间的时候修复

## 测试流程

需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试

## 缺陷的生命周期

新建bug--打开bug--修复bug--回归bug--关闭bug

## 软件测试的核心竞争力是什么

测试人员的核心竞争力在于提早发现问题，并能够发现别人无法发现的问题

- 早发现问题：问题发现越早，解决的成本越低。

## 测试项目具体工作

- 搭建测试环境
- 撰写测试用例
- 执行测试用例
- 写测试计划，测试报告
- 跟踪bug修改情况
- 执行自动化测试，编写脚本，执行，分析，报告
- 进行性能测试，压力测试，执行，分析，调优，报告

## Python的映射类型

字典

## 元祖列表字典区别

元祖：封闭的列表，一旦定义，就不可改变（添加、删除、修改）

列表：可以随意增加和删除任何东西 `append()` 添加`del()`删除

```python
#!/usr/bin/python
# 访问列表
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5, 6, 7 ]
 
print "list1[0]: ", list1[0]
# list1[0]:  physics
print "list2[1:5]: ", list2[1:5]
# list2[1:5]:  [2, 3, 4, 5]

# 更新列表
list = []          ## 空列表
list.append('Google')   ## 使用 append() 添加元素
list.append('Runoob')
print (list)
# ['Google', 'Runoob']

# 删除列表
list1 = ['physics', 'chemistry', 1997, 2000]
 
print list1
del list1[2]
print ("After deleting value at index 2 : ")
print (list1)
# ['physics', 'chemistry', 2000]
```

字典：key-value键值对的形式，键唯一，且不可变 `del` 删除字典 

```python
#!/usr/bin/python
 
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
 
dict['Age'] = 8 # 更新
dict['School'] = "RUNOOB" # 添加
 
print "dict['Age']: ", dict['Age']
# dict['Age']:  8
print "dict['School']: ", dict['School']
# dict['School']:  RUNOOB

del dict['Name']  # 删除键是'Name'的条目
dict.clear()      # 清空字典所有条目
del dict          # 删除字典
```

## 进程 线程 协程

### 进程

- 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立。
- 稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制。

### 线程

- CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享进程的所有资源。
- 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃。

### 协程

- 子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

## GIL

简而言之，python全局解释器锁或GIL是一种互斥锁，仅允许一个线程持有python解释器的控制权。

GIL是python的`全局解释器锁`，同一进程中假如有多个线程运行，一个线程再运行python程序的时候会霸占python解释器(加了一把锁即GIL)，使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。

一般来说我们通过锁来解决内存方面的问题

## 常见的web自动化元素定位方式

- id：根据id来获取元素，返回单个元素，id值一般是唯一的。
- name：根据元素的name属性定位
- tagName：根据元素的标签名定位
- className：根据元素的样式class值定位
- linkText：根据超链接的部分
- partialLinkText：css选择器定位
- xpath

## App性能测试的指标

- 内存
- cpu
- 流量
- 电量
- 启动速度
- 滑动速度、界面切换速度
- 与服务器交互的网络速度

## Web测试和App测试的不同点

### 系统架构方面：

web项目，一般都是B/S架构，基于浏览器的

app项目，则是C/S的，必须要有客户端，用户需要安装客户端

web测试只要更新服务器端，客户端就同步会更新；app项目则需要客户端和服务器都更新。

### 性能方面：

web页面主要会关注响应时间；

app需要关注流量、电量、cpu、gpu、内存等

### 兼容方面：

web是基于浏览器的，所以更倾向浏览器和电脑硬件，电脑系统的的兼容，

app测试则要看分辨率，屏幕尺寸，还要看设备系统；

web测试是基于浏览器的所以不必考虑安装卸载，

app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件；

app还有一些专项测试：如网络、适配性

## Fiddler抓包

### 断点方式有哪些

- Before Requests：在请求时，没有达到服务器之前设置断点。
- After responses：服务器响应之后，在fiddler将响应传回给客户端之前。
- Disabled 取消断点

### 为什么要设置断点

> 进行接口测试时，拦截和修改数据，测后端功能。比如：某图书网小说售价100元，进行网页前端的功能测试时，只能输入100元进行购买！但是通过fiddler抓包工具可以拦截，修改数据。防止跳过前端输入框验证，然后修改数据，输入-100元进行购买，这样的话，不仅买了小说，账户余额还增加100元。这样说明后端接口不对

### 怎么设置断点

- Rules>>Automatic Breakpoints>>Before Requests(After Response) -- 全局断点

- 在命令行输入:（单个断点）

  1.bpu 接口链接 然后回车 --before request

  2.bafter 接口链接 然后回车 -- after response

### 拦截来自某个网址所有请求

在命令行输入：bpu 网址

### 设置抓取https请求

Tools-->Options-->HTTPS，勾选CaptureHTTPS CONNECTs、Decrypt HTTPS tranffic、Ignore serve certificate errors 点击ok，会弹出证书确认即可

### 设置抓取手机app的包

1、配置移动端证书检查，Tools-->Connections-->勾选Allow remote co mputers to connect

2、手机设置方式，配置代理输入ip+端口 登陆ip地址下载证书安装即可

## Web性能测试工具

### Jmeter测试元件的执行顺序

配置元件->前置处理器->定时器->取样器->后置处理器->断言->监听器

### 什么是JMeter断言？断言的类型有哪些？

断言有助于验证被测服务器是否返回了预期结果。

JMeter中常见断言：

- 响应断言
- 持续时间断言
- 大小断言
- XML断言
- HTML断言

### 列出几个JMeter监听器？

- 集合报告
- 汇总报告
- 查看结果数
- 图形结果
- BeanShell Listener

### 解释计时器(Timer)在JMeter中的作用是什么？

在计时器的帮助下，JMeter可以延迟线程发出的每个请求之间的时间。可以解决服务器的过载问题。

### 整体流程

JMeter的操作的整体流程，首先创建一个线程组，指定并发的线程数量，然后指定的要测试的接口，创建相应的监听器，比如表格结果，结果数和聚合报告信息，通过监听器来监听测试是否通过接口是否存在什么问题

其中结果树中可以检测到整体的请求信息，就拿Http请求这种来讲，其实就是整个http协议的所有信息，包括请求头，请求参数，请求路径，还有响应头，响应结果等信息，对于表格查看结果，可以看到每个请求的简单信息，本次请求的时间，以及平均时间。

在聚合报告中，我们就可以看到整体的信息了。比如可以看到平均响应时间，90%Line也就是90%的用户请求低于的时间。还有吞吐量TPS，还有错误率，还有流量来计算吞吐量。

吞吐量=（请求数）/（总时间）

### JMeter参数化

做压力测试时。我们经常需要替换参数，在JMeter中，可以在测试计划中设置全局参数，可以设置用户参数，还可以在前置处理器中设置用户参数。在进行多线程并发的时候，如果需要多个参数，可以使用csv配置元件。

### JMeter连接手机做性能测试

- 启动Jmeter
- 添加线程组--逻辑控制器--录制控制器
- 添加测试计划--非测试元件--HTTP代理服务器
- 手机就类似像fiddler一样配置wifi+端口
- 启动代理服务器
- 进行操作，此时JMeter就开始录制
- 删除不必要的请求
- 保存jmx脚本
- 添加观察结果数
- 回放

### JMeter中的聚合报告每个指标代表什么？

- Lable：每个JMeter 的element都有一个Name属性

- #Samples：发出多少个请求
- Average：平均响应时间(单个request的平均响应时间)
- Media：中位数，50%用户的响应时间
- 90%Line～99%Line：90%～99%用户的响应时间
- Min：最小响应时间
- Maxmun：最大响应时间
- Error%：测试中出现的错误率
- Throughput：吞吐量——每秒完成的请求数
- Received KB/src：每秒从服务器端接收到的数据量
- Sent KB/src：每秒从客户端发送的请求和数量

## web测试，怎么写？

Web测试主要从下面几个大方向考虑

功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等

性能测试，考虑链接速度测试，以及负载测试，例如：web应用系统能允许多少个用户同时在线？如果超了这个数量，会出现什么现象？web应用系统能否处理大量用户对同一个页面的请求？还有压力测试，可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等。

- 现在web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等
- web应用系统是否有超时的限制，也就是说，用户登陆后一定时间内，没有点击任何页面，是否需要重新登陆才能正常使用。
- 为了保证web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。
- 当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。
- 服务端的脚本常常构成安全漏洞，有些漏洞又常常被黑客利用。所以。还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。

## 如何测试手机开机键

- 功能测试：

按下开机键，屏幕是否亮起。

- 性能测试

按下开机键，屏幕是否在规定时间内亮起

- 压力测试

连续多次按下开机键，观察屏幕是否一直亮起，到多久时间失灵

- 健壮性测试

给一个中了病毒的手机或淘汰许久的老机子，安歇开机键观察屏幕能否亮起

- 可靠性测试

连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数

- 可用性测试

开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便

## 印象深刻的bug，接口测试出现bug的原因有哪些？

- 特殊值处理不当导致程序异常退出或者崩溃
- 类型边界溢出，导致数据独处写入不一致
- 取值边界外未返回正确的错误信息
- 权限为处理，可以访问其他用户的信息
- 逻辑校验不完善，可以利用漏洞获取非正当利益
- 状态处理不当，导致逻辑出现错误
- 数组类型item个数为0或者item重复时程序异常退出

## 压力测试如何做？

- 首先对要测试的系统进行分析，明确需要对那一部分做压力测试，比如秒杀，支付。
  - 第一种方式可以通过写脚本产生压力机器人对服务器进行发包收报操作
  - 第二种借助一些压力测试工具，Jmeter，LoadRunner
- 如何对这些压力测试点进行正确的施压
  - 需要压力测试工具或者其他方法录制脚本，模拟用户的操作
- 对测试点设计多大的压力比较合适
  - 需要明确压力测试限制的数量，即用户并发量
- 测试结束后如何通过这些数据来定位性能问题
  - 通过测试可以得到吞吐量，平均响应时间等数据，这个数据的背后是整个后台处理逻辑综合作用的结果，这时候就可以先关注系统CPU，内存，然后对比吞吐量，平均响应时间达到瓶颈时这些数据的情况，然后就能明确性能问题是系统的那一块造成的。

## 功能测试和接口测试是怎么做的？

- 功能测试

首先制定测试计划，然后进行测试设计，将在测试阶段指定的测试活动分解，进而细化，为若干个可执行程序的子测试过程，然后执行测试，按照测试计划使用测试用例对待测项目进行逐一的，详细的排查分析评估，最后对测试结果进行统计和分析

- 接口测试

接口测试也是属于功能测试，所以跟我们以往的功能测试流程并没有太大的区别，测试流程依旧是: 1.测试接口文档(需求文档) 2.根据接口文档编写测试用例(用例编写完全可以按照以往规则来编写，例如等价划分，边界值等设计方法) 3.执行测试，查看不同的参数请求，接口的返回的数据是否达到预期。

## 测试工具用过哪些？

- 自动化测试工具用过selenium和uiautomator2

- 性能测试工具用过Jmeter

## 设计一个微信朋友圈点赞的用例

- 功能测试：

点赞某条朋友圈，验证是否成功

- 接口测试：

点赞朋友圈，验证朋友能否收到提示信息

- 性能测试

点赞朋友圈，是否在规定的时间显示结果，是否在规定的时间在朋友手机上进行提示

- 兼容性测试

在不同的终端，比如ipad，手机上点赞朋友圈，验证是否成功

## 前端和后端吵起来都说不是自己的问题，作为测试的我们，该怎么办？

此时应该找技术leader拍板或leader们基于安全性、性能、可测试性、可维护性讨论敲定一个解决方案，做到开发环境方便开发，线上环境少配置，少依赖，少出错机会。

## 如何对登陆界面进行测试

::: details

- 黑盒测试方法

输入正确用户名和密码，验证是否登陆成功

输入正确的用户名和错误的密码，验证是否登陆失败并且提示信息正常

输入未注册的用户名和任意密码，验证是否登陆失败并且提示信息正确

用户名和密码都为空，验证是否登陆失败并且提示信息正确

用户名和密码两者之一为空

若启用了验证码，输入正确的用户名验证码是否能登陆成功

输入正确用户名和密码，错误的验证码，能否登陆成功并且提示信息正确

用户名和密码是否大小写敏感

页面上的密码框是否加密显示

后台系统第一次创建的用户重新登陆时是否提示修改密码

忘记用户名和忘记密码的功能是否可用

前端功能是否根据要求限制用户名和密码的长度

点击验证码图片是否可以更换验证码，更换后验证码是否可用

刷新页面是否会刷新验证码

如果验证码具有实效性，分别验证时效内和时效外验证码的有效性

用户登陆成功但是会话超时后是否重定向到用户登陆界面

不同级别的用户登陆系统后的权限是否正确

页面默认定位焦点是否定位到用户输入框中

快捷键tab和回车键是否可以正常使用

- 安全

用户密码后台存储是否加密

用户密码在网络传输过程中是否加密

密码是否具有有效期，密码有效期到期后是否提示修改密码

不登陆的时候直接在浏览框中输入登陆界面后url地址，是否重新定位到登陆界面

密码输入框是否不支持复制粘贴

页面密码输入框中输入的密码是否可以在页面源码模式下被查看

用户名和密码输入框中输入xss跨站脚本攻击字符串验证系统的行为是否被篡改

连续多次登陆失败后系统是否会阻止用户后续的尝试

统一用户在同一终端的多种不同的浏览器上登陆，验证登陆功能的互斥性是否符合设计预期

同一用户先后在不同终端的浏览器上登陆用户名和密码输入框中输入典型sql注入攻击字符串验证系统的返回页面

- 性能测试

单用户登陆的响应界面是否符合预期

单用户登陆时后台请求数量是否过多

高并发场景下用户登陆的响应界面是否符合预期

高并发场景下服务端的监控指标是否符合预期

高集合点并发场景下是否存在资源死锁和不合理的资源等待

长时间大量用户连续登陆和退出，服务端是否存在内存泄漏

- 兼容测试

不同浏览器下验证登陆功能的页面显示和功能正确性

相同浏览器的不同版本下验证登陆功能的页面显示和功能正确性

不同终端的不同浏览器下验证登陆功能的页面显示和功能正确性

不同分辨率下的页面显示和功能正确性

- 弱网测试

网路切换和网络延迟时登陆界面是否正常

是否支持第三方登录

是否可记住密码，记住的密码是否加密

:::

## 性能测试有哪些指标？对一个登陆功能做性能测试，有哪些指标？如何测出可同时处理的最大请求数量？

- 性能测试常用指标

1、吞吐量：每秒钟系统能够处理的请求数，任务数

2、响应时间：服务处理一个请求或一个任务的耗时

3、错误率：一批请求中结果出错的请求所占比例

从服务器的角度看，性能测试关注cpu，内存，服务器负载，网络，磁盘I/O

- 对登陆功能做性能测试

1、单用户登陆的响应界面是否符合预期

2、单用户登陆时后台请求的数量是否过多

3、高并发场景下服务端的监控指标是否符合预期

4、高集合点并发场景下是否存在资源死锁和不合理的资源等待

5、长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏

- 如何测可同时处理最大请求数量

可以采用性能测试工具(WeTest服务器性能)，能提供10W+以上的并发量，测出服务器模型最大并发

## 数据库

### 基本的SQL语句

::: details

选择：select * from table1 where 范围

插入：insert into table1(field1,field2) values (value1,value2)

删除：delete from table1 where 范围

更新：update table1 set field1=value1 where 范围

查找：select * from table1 where field1 like "%value1%"

排序：select * from table1 order by fidld1,field2[desc]

总数：select count as totalcount from table1

求和：select sum(field1) as sumvalue from table1

平均：select avg(field1) as avgvalue from table1

最大：select max(field1) as maxvalue from table1

最小：select min(field1) as minvalue from table1

:::

##  某个表格存着s_name subject score 三个字段，比如某一行是 张三 数学 76，现在要选取出所有科目成绩都大于80分的学生名字，请写出sql语句

```sql
select s_name from table_name where s_name
not in (select s_name from table_name) where score < 80
```

## 写出sql语句：数据库统计总成绩取前十名的学生

```sql
select * from 
(select * from stu order by grade desc)
limit 10;
```

## 请问count和sum的区别，以及count(*)和count(列名)的区别

- count和sum区别

求和用累加sum()，求行的个数用累计count

- count(*)和count(列名)区别

count(*) 包括了所有的列，在统计结果的时候不会忽略列值为null

count(列名)只包括列名那一项，会忽略列值为空的计数
